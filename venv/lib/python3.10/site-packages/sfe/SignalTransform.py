from sfe_aux_tools import nextpow2, cross_correlation
from spectrum import pmtm
from spectrum import dpss
import numpy as np


class SignalTransform:
    ps = None

    def __init__(self, signal, frequency_sample = 128.0, nw = 2.5, k = None):
        self.signal = signal
        self.Fs = frequency_sample
        self.nw = nw
        self.k = k

        if self.k == None:
            self.k = self.nw * 2

        if self.signal.ndim == 1:
            self.ntft = max(256, 2 ** nextpow2(len(self.signal)))
	#consertar
        elif (self.signal.ndim == 2):
            self.ntft = max(256, 2 ** nextpow2(len(self.signal.reshape(-1))))


    def get_cross_correlogram(self, signal_ref):
        cc = None

        if len(self.signal) == len(signal_ref):
            cc = [cross_correlation(self.signal, signal_ref, i) for i in range(-(len(self.signal) - 1), len(signal_ref))]

        return cc


    def get_power_spectrum(self): #, data_taper = None
        #if (data_taper != None) and (len(data_taper[0]) == len(self.signal)):
        
        ps, w, e = pmtm(self.signal, NW = self.nw, k = self.k, show = False)
        ps = abs(ps)**2
        ps = ps.transpose()
        ps = np.mean(ps * w, axis = 1)

        self.ps = ps

        return ps


    def get_spectrogram(self, window_len = 128):
        sg = []
        tapers, eigen = dpss(window_len, NW = self.nw, k = self.k)

        if len(self.signal) >= window_len:
            for i in range(0, len(self.signal) - window_len + 1):
                ps, w, e = pmtm(self.signal[i : i + window_len], e = eigen, v = tapers, show = False)

                ps = abs(ps)**2
                ps = ps.transpose()
                ps = np.mean(ps * w, axis=1)

                sg.append(ps)

        sg = np.asarray(sg)

        return sg.T


    def get_bispectrogram(self):
        if (self.ps == None) or (len(self.ps) == 0):
            self.ps = self.get_power_spectrum()

        bs = np.zeros((int(len(self.ps) / 2) - 1, int(len(self.ps) / 2) - 1))

        for i in range(0, len(bs)):
            for j in range(0, len(bs) - i):
                bs[i, j] = self.ps[i] * self.ps[j] * self.ps[i + j]
                bs[j, i] = bs[i, j]

        return bs
