''' Module implemented for feature extraction from two-dimensional sequences.
    Examples: multivariate time series, or spectrogram 

    @author: Jefferson Tales Oliva
    @email: jeffersonoliva@utfpr.edu.br


    References
    ----------
    Boonyakitanont, P.; Lek-uthai, A.; Chomtho, K.; Songsiri, J. A review of 
    feature extraction and performance evaluation in epileptic seizure 
    detection using EEG. Biomedical Signal Processing and Control, v. 57, 
    p. 101702, 2020.
    
    Costa, M., Goldberger, A. L., Peng, C. K. Multiscale entropy analysis of 
    biolgical signals. Physical Review E, v. 71, n. 2, p. 021906, 2005
    
    Easton Jr, R. L. Fourier methods in imaging. John Wiley & Sons, 2017.
    
    Fredman, D.; Pisani, R.; Ourvers, R. Statistics. Norton, 1988.
    
    Oliva, J. T. Automatic generation of medical reports for epilepsy diagnosis
    through electroencephalogram processing using machine learning (in 
    Portuguese). PhD Thesis -- University of São Paulo (USP), São Carlos, 
    Brazil, 2018.

    Oliva, J. T., Rosa, J. L. G. Classification for EEG report generation and 
    epilepsy detection. Neurocomputing, v. 335, p. 81--95, 2019.
    
    Proakis, J. G.; Manolakis, D. K. Digital signal processing: principles, 
    algorithms, and application. Saddle River, EUA: Prentice Hall, 2006.
    
    Ramaligam, A.; Krishnan, S. Gaussian mixture modeling using short time 
    Fourier transform features for audio fingerprinting. In: IEEE, 14. 
    Proceedings of the International Conference on Multimedia and Expo. 
    Amsterdam, Netherlands, 2005. 
    
    Shannon, C. E. A mathematical theory of communication. The Bell System 
    Technical Journal, IEEE, v. 27, n. 3, p. 379–423, 1948.
    
    Sweitzer, K.; Bishop, N.; Genberg, V. Efficient computation of spectral 
    moments for determination of random response statistics. 2004.
    
    Zhou, S.; Gan, J. Q.; Sepulveda, F. Classifying mental tasks based on 
    features of higherorder statistics from EEG signals in brain–computer 
    interface. Information Sciences, Elsevier, v. 178, n. 6, p. 1629–1640, 
    2008.
    
    
    Links
    -----
    
    
'''
from sfe.sfe_aux_tools import getfgrid
import numpy as np
import typing as t
#from collections import Counter
#from scipy.stats import kurtosis, skew

# two-dimensional sequence feature extractor
# https://en.wikipedia.org/wiki/Contrast_(vision)
class TDSFeatureExtractor:
    """Bidimensional array feature extractor: This class provides methods for
    feature extraction from time- or time-frequency domain representations of
    signals.
    
    Attributes
    ----------
    mat : numpy.ndarray
        Bidimensional sequence which represents a multivariate time 
        series (time domain) or spectrogram (time-frequency domain)
    
    freq_grid : numpy.ndarray (default = None)
        Frequency grid that represent the frequency values of the "seq" 
        elements. For example, the i-th "seq" element is sampled at 
        freq_grid[i] Hz. In this sense, if "freq_grid" has default 
        value (None) or is not created, extracted features are from time domain,
        i.e. some measures can not be extracted, such as peak frequency, 
        1st-order moment, 2nd-order moment, spectral centroid, and spectral 
        entropy. If "freq_grid" is different from None or created during the
        "ODFeatureExtractor" instancing, all measures can be computed.
    
    label : string (default = '')
        String concatenated to each feature name. In an electroencephalogram,
        for example, power spectrum features are commonly extracted by 
        frequency range, such as delta [1-4 Hz], theta [4-8 Hz], 
        alpha [8--12 Hz], etc. Thus, the "delta" label could be concatenated to
        each feature name during its extraction into delta range from a power
        spectrum.
        
    __extracted_features : dict (default = {})
        A dictionary which represents a set of extracted features.
        
    """
    __extracted_features = {}
    
    freq_grid = None
    
    mat_mean = None
    mat_std = None
    mat_min = None
    mat_peak = None
    #mat_peak_frequency = None
    mat_Q1 = None
    mat_Q2 = None
    mat_Q3 = None
    mat_Q_range = None
    mat_amplitude = None
    spec_freq_centroid = None
    #spec_time_centroid == None
    mean_line_length = None
    Michelson_contrast = None
    rms_contrast = None
    sum_freq_time_ratio = None # inventei
    correlation = None
    mat_entropy = None
    '''mat_kurtosis = None
    mat_skewness = None
    mat_coef_var = None
    mat_flatness = None
    mat_1st_moment = None
    mat_2nd_moment = None
    mat_rms = None
    mat_crest_factor = None
    mat_mean_nonlinear_energy = None
    mat_Hurst_exponent = None
    mat_Hjorth_activity = None
    mat_Hjorth_mobility = None
    mat_Hjorth_complexity = None
    mat_spectral_entropy = None
    mat_Renyi_entropy = None
    mat_Shannon_entropy = None'''

    def __init__(self, mat: t.Optional[np.ndarray], Fs = None, 
                 freq_grid: t.Optional[np.ndarray] = None, label = ''):
        """
        Non-instantiable parameter:
        ---------------------------
        Fs : int or float (default = None)
            Frequency sampling rate. If this parameter is not None, a frequency
            grid ("freq_grid") is created for extraction of some features based
            on power spectrum.
            
        """
        self.mat = mat #np.asmatrix(spec)
        self.label = label

        # If Fs or freq_grid is different from None, seq is a power 
        # spectrum (frequency domain). Otherwise, seq is a time series (time 
        # domain)
        if Fs is not None:
            self.freq_grid = getfgrid(Fs, len(mat))
        else:
            self.freq_grid = freq_grid


    def get_mat_mean(self):
        if self.mat_mean == None:
            self.mat_mean = np.mean(self.mat)

        return self.mat_mean


    def get_mat_std(self):
        if self.mat_std == None:
            self.mat_std = np.std(self.mat)

        return self.mat_std


    def get_mat_min(self):
        if self.mat_min == None:
            self.mat_min = np.min(self.mat)

        return self.mat_min


    def get_mat_peak(self):
        if self.mat_max == None:
            self.mat_max = np.max(self.mat)

        return self.mat_max


    '''def get_mat_peak_frequency(self):
        return self.mat_peak_frequency'''


    def get_mat_Q1(self):
        if self.mat_Q1 == None:
            self.mat_Q1 = np.percentile(self.mat, 25)

        return self.mat_Q1


    def get_mat_Q2(self):
        if self.mat_Q2 == None:
            self.mat_Q2 = np.percentile(self, 50)

        return self.mat_Q2


    def get_mat_Q3(self):
        if self.mat_Q3 == None:
            self.mat_Q3 = np.percentile(self.mat, 75)

        return self.mat_Q3


    def get_mat_Q_range(self):
        if self.mat_Q_range == None:
            self.get_mat_Q1()
            self.get_mat_Q3()

            self.mat_Q_range = self.mat_Q3 - self.mat_Q1

        return self.mat_Q_range


    def get_mat_amplitude(self):
        if self.mat_amplitude == None:
            self.get_mat_min()
            self.get_mat_peak()

            self.mat_amplitude = self.mat_peak - self.mat_min

        return self.mat_amplitude


    def get_spec_time_centroid(self, Fs = None):
        if self.spec_time_centroid == None:
            self.spec_time_centroid = np.sum(self.mat * np.asmatrix(
                self.__estimate_time_grid(Fs)).T) / self.mat.sum()

        return self.spec_freq_centroid


    def __estimate_time_grid(self, Fs = None):
        app_time = 1

        if Fs != None:
            app_time = len(self.mat[0])
        # approximate time duration of the spectrogram
        elif self.freq_grid != None:
            app_time = len(self.freq_grid) / (round(self.freq_grid[-1]) - round(self.freq_grid[0]))

        return np.asarray(range(len(self.mat[0]))).reshape(-1) * app_time


    def get_spec_freq_centroid(self):
        if (self.spec_freq_centroid == None) and (self.freq_grid != None):
            self.spec_freq_centroid = np.sum(self.mat.T * np.asmatrix(self.freq_grid).T) / np.sum(self.mat)

        return self.spec_freq_centroid


    def get_mean_line_length(self):
        if self.mean_line_length == None:
            self.mean_line_length = np.mean(np.sum([abs(self.mat[:, i] - self.mat[:, i - 1])
                                                    for i in range(1, len(self.mat[0]))]))
        return self.mean_line_length


    def get_Michelson_contrast(self):
        if self.Michelson_contrast == None:
            self.Michelson_contrast = (self.mat.max() - self.mat.min()) / (self.mat.max() + self.mat.min())

        return self.Michelson_contrast


    def get_rms_contrast(self):
        if self.rms_contrast == None:
            self.get_mat_mean()

            self.rms_contrast = np.sqrt(np.sum([[(self.mat[i,j] - self.mat_mean)**2
                                                 for i in range(len(self.mat))] for j in range(len(self.mat[0]))]))
        return self.rms_contrast


    #acabei de inventar
    def get_sum_freq_time_ratio(self):
        if self.sum_freq_time_ratio == None:
            t_grid = self.__estimate_time_grid()

            self.sum_freq_time_ratio = np.sum(self.mat.sum(axis = 1) *
                                              self.freq_grid) / np.sum(self.mat.sum(axis = 0) * t_grid)
        return self.sum_freq_time_ratio


    def get_correlation(self):
        if self.correlation == None:
            me = np.mean(self.mat.sum(axis = 0)) * np.mean(self.mat.sum(axis = 1))
            sd = np.std(self.mat.sum(axis = 0)) * np.std(self.mat.sum(axis = 1))

            self.correlation = np.sum([[i * j * self.mat[i, j] - me
                                        for i in range(len(self.mat))] for j in range(len(self.mat[0]))]) / sd

        return self.correlation


    def get_mat_entropy(self):
        if self.mat_entropy == None:
            self.mat_entropy = - np.sum([[self.mat[i, j] * np.log(self.mat[i, j])
                                        for i in range(len(self.mat))] for j in range(len(self.mat[0]))])

        return self.mat_entropy


    '''def get_mat_kurtosis(self):
        return self.


    def get_mat_skewness(self):
        return self.


    def get_mat_coef_var(self):
        return self.


    def get_mat_flatness(self):
        return self.


    def get_mat_1st_moment(self):
        return self.


    def get_mat_2nd_moment(self):
        return self.


    def get_mat_rms(self):
        return self.


    def get_mat_crest_factor(self):
        return self.


    def get_mat_mean_nonlinear_energy(self):
        return self.


    def get_mat_Hurst_exponent(self):
        return self.


    def get_mat_Hjorth_activity(self):
        return self.


    def get_mat_Hjorth_mobility(self):
        return self.


    def get_mat_Hjorth_complexity(self):
        return self.


    def get_mat_spectral_entropy(self):
        return self.


    def get_mat_Renyi_entropy(self):
        return self.


    def get_mat_Shannon_entropy(self):
        return self.'''





    def __generate_feature_dictionary(self):
        dic_features = {'mat_mean_' + self.label: self.mat_mean,
                        'mat_std_' + self.label: self.mat_std,
                        'mat_min_' + self.label: self.mat_min,
                        'mat_peak_' + self.label: self.mat_peak,
                        'mat_Q1_' + self.label: self.mat_Q1,
                        'mat_Q2_' + self.label: self.mat_Q2,
                        'mat_Q3_' + self.label: self.mat_Q3,
                        'mat_Q_range_' + self.label: self.mat_Q_range,
                        'mat_amplitude_' + self.label: self.mat_amplitude,
                        'spec_freq_centroid' + self.label: self.spec_freq_centroid,
                        'spec_time_centroid' + self.label: self.spec_time_centroid,
                        'mean_line_length_' + self.label: self.mean_line_length,
                        'Michelson_contrast_' + self.label: self.Michelson_contrast,
                        'rms_contrast_' + self.label: self.rms_contrast,
                        'sum_freq_time_ratio' + self.label: self.sum_freq_time_ratio, # acabei de inventar
                        'correlation' + self.label: self.correlation, # acabei de inventar
                        'mat_entropy' + self.label: self.mat_entropy, # acabei de inventar



                        'mat_kurtosis_' + self.label: None,
                        'mat_skewness_' + self.label: None,
                        'mat_nonlinear_energy_' + self.label: None,
                        'mat_Hurst_exponent_' + self.label: None,
                        'mat_Shannon_entropy_' + self.label: None,
                        'mat_Renyi_entropy_' + self.label: None,
                        'mat_sbe_' + self.label: None, # spectral band energy
                        'mat_sbw_' + self.label: None, # spectral band width
                        'mat_approximate_entropy_' + self.label: None,
                        'mat_sample_entropy_' + self.label: None,
                        'mat_rms_' + self.label: None,
                        'mat_crest_factor_' + self.label: None,
                        'mat_var_coef_' + self.label: None}

        return dic_features




'''
    def __compute_measures(self, sg, fg):
        dic_features = self.__generate_feature_dictionary(self.label)
        rSG = self.mat.reshape(-1)
        sSG = sg.reshape(-1) # sample sg

        print(self.label)


        dic_features['mat_kurtosis_' + self.label] = kurtosis(sSG)
        #print('skewness')
        dic_features['mat_skewness_' + self.label] = skew(sSG)
        #print('nonlinear_energy')
        dic_features['mat_nonlinear_energy_' + self.label] = nonlinear_energy(sSG)
        #print('Hurst_exponent')
        dic_features['mat_Hurst_exponent_' + self.label] = Hurst_exponent(sSG)
        #print('Shannon_entropy')
        dic_features['mat_Shannon_entropy_' + self.label] = Shanon_entropy(sSG)
        #print('mat_Renyi_entropy')
        dic_features['mat_Renyi_entropy_' + self.label] = Renyi_entropy(sSG)

        dic_features['mat_sbe_' + self.label] = np.sum(sSG) / np.sum(rSG)
        #print('sbw')
        dic_features['mat_sbw_' + self.label] = np.matrix.sum(np.asmatrix(sg * np.asarray(np.asmatrix((fg - dic_features['mat_centroid_' + self.label]) ** 2).T))) / np.sum(rSG)

        dic_features['mat_rms_' + self.label] = sqrt(sum(sSG ** 2)) / len(sSG)
        #print('crest_factor')
        dic_features['mat_crest_factor_' + self.label] = dic_features['mat_peak_' + self.label] / dic_features['mat_rms_' + self.label]
        #print('var_coef')
        dic_features['mat_var_coef_' + self.label] = dic_features['mat_average_' + self.label] / dic_features['mat_std_' + self.label]


#dic_features['centroid_' + self.label] = np.sum(ps * fg) / np.sum(ps)

        # ver isso
        return dic_features
'''