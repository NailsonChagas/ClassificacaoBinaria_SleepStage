#from sfe.sfe_aux_tools import *
import numpy as np
#from scipy.stats import kurtosis
#from scipy.stats import skew

# two-dimensional sequence feature extractor
# https://en.wikipedia.org/wiki/Contrast_(vision)
class TDSFeatureExtractor:
    freq_grid = None
    mat_mean = None
    mat_std = None
    mat_min = None
    mat_peak = None
    #mat_peak_frequency = None
    mat_Q1 = None
    mat_Q2 = None
    mat_Q3 = None
    mat_Q_range = None
    mat_amplitude = None
    spec_freq_centroid = None
    #spec_time_centroid == None
    mean_line_length = None
    Michelson_contrast = None
    rms_contrast = None
    sum_freq_time_ratio = None # inventei
    correlation = None
    mat_entropy = None
    '''mat_kurtosis = None
    mat_skewness = None
    mat_coef_var = None
    mat_flatness = None
    mat_1st_moment = None
    mat_2nd_moment = None
    mat_rms = None
    mat_crest_factor = None
    mat_mean_nonlinear_energy = None
    mat_Hurst_exponent = None
    mat_Hjorth_activity = None
    mat_Hjorth_mobility = None
    mat_Hjorth_complexity = None
    mat_spectral_entropy = None
    mat_Renyi_entropy = None
    mat_Shannon_entropy = None'''

    def __init__(self, mat, freq_grid = None, label = ''):
        self.mat = mat #np.asmatrix(spec)
        self.label = label

        # If freq_grid is different from None, mat is a spectrogram
        # Otherwise, mat can be, for example, a level-gray image
        self.freq_grid = freq_grid


    def get_mat_mean(self):
        if self.mat_mean == None:
            self.mat_mean = np.mean(self.mat)

        return self.mat_mean


    def get_mat_std(self):
        if self.mat_std == None:
            self.mat_std = np.std(self.mat)

        return self.mat_std


    def get_mat_min(self):
        if self.mat_min == None:
            self.mat_min = np.min(self.mat)

        return self.mat_min


    def get_mat_peak(self):
        if self.mat_max == None:
            self.mat_max = np.max(self.mat)

        return self.mat_max


    '''def get_mat_peak_frequency(self):
        return self.mat_peak_frequency'''


    def get_mat_Q1(self):
        if self.mat_Q1 == None:
            self.mat_Q1 = np.percentile(self.mat, 25)

        return self.mat_Q1


    def get_mat_Q2(self):
        if self.mat_Q2 == None:
            self.mat_Q2 = np.percentile(self, 50)

        return self.mat_Q2


    def get_mat_Q3(self):
        if self.mat_Q3 == None:
            self.mat_Q3 = np.percentile(self.mat, 75)

        return self.mat_Q3


    def get_mat_Q_range(self):
        if self.mat_Q_range == None:
            self.get_mat_Q1()
            self.get_mat_Q3()

            self.mat_Q_range = self.mat_Q3 - self.mat_Q1

        return self.mat_Q_range


    def get_mat_amplitude(self):
        if self.mat_amplitude == None:
            self.get_mat_min()
            self.get_mat_peak()

            self.mat_amplitude = self.mat_peak - self.mat_min

        return self.mat_amplitude


    def get_spec_time_centroid(self, Fs = None):
        if self.spec_time_centroid == None:
            self.spec_time_centroid = np.sum(self.mat * np.asmatrix(
                self.__estimate_time_grid(Fs)).T) / self.mat.sum()

        return self.spec_freq_centroid


    def __estimate_time_grid(self, Fs = None):
        app_time = 1

        if Fs != None:
            app_time = len(self.mat[0])
        # approximate time duration of the spectrogram
        elif self.freq_grid != None:
            app_time = len(self.freq_grid) / (round(self.freq_grid[-1]) - round(self.freq_grid[0]))

        return np.asarray(range(len(self.mat[0]))).reshape(-1) * app_time


    def get_spec_freq_centroid(self):
        if (self.spec_freq_centroid == None) and (self.freq_grid != None):
            self.spec_freq_centroid = np.sum(self.mat.T * np.asmatrix(self.freq_grid).T) / np.sum(self.mat)

        return self.spec_freq_centroid


    def get_mean_line_length(self):
        if self.mean_line_length == None:
            self.mean_line_length = np.mean(np.sum([abs(self.mat[:, i] - self.mat[:, i - 1])
                                                    for i in range(1, len(self.mat[0]))]))
        return self.mean_line_length


    def get_Michelson_contrast(self):
        if self.Michelson_contrast == None:
            self.Michelson_contrast = (self.mat.max() - self.mat.min()) / (self.mat.max() + self.mat.min())

        return self.Michelson_contrast


    def get_rms_contrast(self):
        if self.rms_contrast == None:
            self.get_mat_mean()

            self.rms_contrast = np.sqrt(np.sum([[(self.mat[i,j] - self.mat_mean)**2
                                                 for i in range(len(self.mat))] for j in range(len(self.mat[0]))]))
        return self.rms_contrast


    #acabei de inventar
    def get_sum_freq_time_ratio(self):
        if self.sum_freq_time_ratio == None:
            t_grid = self.__estimate_time_grid()

            self.sum_freq_time_ratio = np.sum(self.mat.sum(axis = 1) *
                                              self.freq_grid) / np.sum(self.mat.sum(axis = 0) * t_grid)
        return self.sum_freq_time_ratio


    def get_correlation(self):
        if self.correlation == None:
            me = np.mean(self.mat.sum(axis = 0)) * np.mean(self.mat.sum(axis = 1))
            sd = np.std(self.mat.sum(axis = 0)) * np.std(self.mat.sum(axis = 1))

            self.correlation = np.sum([[i * j * self.mat[i, j] - me
                                        for i in range(len(self.mat))] for j in range(len(self.mat[0]))]) / sd

        return self.correlation


    def get_mat_entropy(self):
        if self.mat_entropy == None:
            self.mat_entropy = - np.sum([[self.mat[i, j] * np.log(self.mat[i, j])
                                        for i in range(len(self.mat))] for j in range(len(self.mat[0]))])

        return self.mat_entropy


    '''def get_mat_kurtosis(self):
        return self.


    def get_mat_skewness(self):
        return self.


    def get_mat_coef_var(self):
        return self.


    def get_mat_flatness(self):
        return self.


    def get_mat_1st_moment(self):
        return self.


    def get_mat_2nd_moment(self):
        return self.


    def get_mat_rms(self):
        return self.


    def get_mat_crest_factor(self):
        return self.


    def get_mat_mean_nonlinear_energy(self):
        return self.


    def get_mat_Hurst_exponent(self):
        return self.


    def get_mat_Hjorth_activity(self):
        return self.


    def get_mat_Hjorth_mobility(self):
        return self.


    def get_mat_Hjorth_complexity(self):
        return self.


    def get_mat_spectral_entropy(self):
        return self.


    def get_mat_Renyi_entropy(self):
        return self.


    def get_mat_Shannon_entropy(self):
        return self.'''





    def __generate_feature_dictionary(self):
        dic_features = {'mat_mean_' + self.label: self.mat_mean,
                        'mat_std_' + self.label: self.mat_std,
                        'mat_min_' + self.label: self.mat_min,
                        'mat_peak_' + self.label: self.mat_peak,
                        'mat_Q1_' + self.label: self.mat_Q1,
                        'mat_Q2_' + self.label: self.mat_Q2,
                        'mat_Q3_' + self.label: self.mat_Q3,
                        'mat_Q_range_' + self.label: self.mat_Q_range,
                        'mat_amplitude_' + self.label: self.mat_amplitude,
                        'spec_freq_centroid' + self.label: self.spec_freq_centroid,
                        'spec_time_centroid' + self.label: self.spec_time_centroid,
                        'mean_line_length_' + self.label: self.mean_line_length,
                        'Michelson_contrast_' + self.label: self.Michelson_contrast,
                        'rms_contrast_' + self.label: self.rms_contrast,
                        'sum_freq_time_ratio' + self.label: self.sum_freq_time_ratio, # acabei de inventar
                        'correlation' + self.label: self.correlation, # acabei de inventar
                        'mat_entropy' + self.label: self.mat_entropy, # acabei de inventar



                        'mat_kurtosis_' + self.label: None,
                        'mat_skewness_' + self.label: None,
                        'mat_nonlinear_energy_' + self.label: None,
                        'mat_Hurst_exponent_' + self.label: None,
                        'mat_Shannon_entropy_' + self.label: None,
                        'mat_Renyi_entropy_' + self.label: None,
                        'mat_sbe_' + self.label: None, # spectral band energy
                        'mat_sbw_' + self.label: None, # spectral band width
                        'mat_approximate_entropy_' + self.label: None,
                        'mat_sample_entropy_' + self.label: None,
                        'mat_rms_' + self.label: None,
                        'mat_crest_factor_' + self.label: None,
                        'mat_var_coef_' + self.label: None}

        return dic_features




'''
    def __compute_measures(self, sg, fg):
        dic_features = self.__generate_feature_dictionary(self.label)
        rSG = self.mat.reshape(-1)
        sSG = sg.reshape(-1) # sample sg

        print(self.label)


        dic_features['mat_kurtosis_' + self.label] = kurtosis(sSG)
        #print('skewness')
        dic_features['mat_skewness_' + self.label] = skew(sSG)
        #print('nonlinear_energy')
        dic_features['mat_nonlinear_energy_' + self.label] = nonlinear_energy(sSG)
        #print('Hurst_exponent')
        dic_features['mat_Hurst_exponent_' + self.label] = Hurst_exponent(sSG)
        #print('Shannon_entropy')
        dic_features['mat_Shannon_entropy_' + self.label] = Shanon_entropy(sSG)
        #print('mat_Renyi_entropy')
        dic_features['mat_Renyi_entropy_' + self.label] = Renyi_entropy(sSG)

        dic_features['mat_sbe_' + self.label] = np.sum(sSG) / np.sum(rSG)
        #print('sbw')
        dic_features['mat_sbw_' + self.label] = np.matrix.sum(np.asmatrix(sg * np.asarray(np.asmatrix((fg - dic_features['mat_centroid_' + self.label]) ** 2).T))) / np.sum(rSG)

        dic_features['mat_rms_' + self.label] = sqrt(sum(sSG ** 2)) / len(sSG)
        #print('crest_factor')
        dic_features['mat_crest_factor_' + self.label] = dic_features['mat_peak_' + self.label] / dic_features['mat_rms_' + self.label]
        #print('var_coef')
        dic_features['mat_var_coef_' + self.label] = dic_features['mat_average_' + self.label] / dic_features['mat_std_' + self.label]


#dic_features['centroid_' + self.label] = np.sum(ps * fg) / np.sum(ps)

        # ver isso
        return dic_features
'''