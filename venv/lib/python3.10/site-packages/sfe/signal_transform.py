"""Module developed for signal representation into different domains

    @author: Jefferson Tales Oliva
    @email: jeffersonoliva@utfpr.edu.br
    
    
    References
    ----------
    Chandaka, S.; Chatterjee, A.; Munshi, S. Cross-correlation aided support 
    vector machine classifier for classification of EEG signals. 
    Expert Systems with Applications, v. 36, n. 2, p. 1329-1336, 2009.
    
    Collis, W. B.; White, P. R.; Hammond, J. K. Higher-order spectra: the 
    bispectrum and trispectrum. Mechanical Systems and Signal Processing, 
    Elsevier, v. 12, n. 3, p. 375--394, 1998.
    
    Oliva, J. T. Automatic generation of medical reports for epilepsy diagnosis
    through electroencephalogram processing using machine learning (in 
    Portuguese). PhD Thesis -- University of São Paulo (USP), São Carlos, 
    Brazil, 2018.

    Oliva, J. T., Rosa, J. L. G. Classification for EEG report generation and 
    epilepsy detection. Neurocomputing, v. 335 p. 81--95, 2019.
    
    Proakis, J. G.; Manolakis, D. K. Digital signal processing: principles, 
    algorithms, and application. Saddle River, EUA: Prentice Hall, 2006.
    
    Rahmatian, M.; Vahidi, B.; Ghanizadeh, A. J.; Gharehpetian, G. B.; 
    Alehosseini, H. A. Insulation failure detection in transformer winding 
    using cross-correlation technique with ANN and k-NN regression method 
    during impulse test. International Journal of Electrical Power & Energy 
    Systems, v. 53, p. 209--218, 2013.
    
    Slepian, D. Prolate spheroidal wave functions, Fourier analysis, and 
    uncertainty -- V: The discrete case. Bell Labs Technical Journal, Wiley 
    Online Library, v. 57, n. 5, p. 1371--1430, 1978. 
    
    Thomson, D. J. Spectrum estimation and harmonic analysis. Proceedings of 
    the IEEE, IEEE, v. 70, n. 9, p. 1055--1096, 1982.
"""

from sfe.sfe_aux_tools import cross_correlation
import typing as t
from spectrum import pmtm, dpss
import numpy as np


class SignalTransform:
    """This class provides methods for signal representation into different domains
    
    Attributes
    ----------
    signal : numpy.ndarray
        A signal (time series) represented as an array.
    
    Fs : int or float (default = 128.0)
        Frequency sampling rate.
    
    nw : int or float (default = 2.5)
        time half bandwidth parameter. Example of a typical value: 2.5.
    
    k : int or float (default = None)
        first k Slepian sequences.
        
    __ps: numpy.ndarray
        Power spectrum generated by the "get_power_spectrum" function. 
        This np.ndarray aims to prevent unnecessary execution of 
        "get_power_spectrum" in "the get_bispectrogram". It is important to
        emphasize that this attribute can not be accessed. I the other words,
        the "__ps" is only an auxiliary attribute.
        
        
    Example
    -------
    >>> from sfe.signal_transform import SignalTransform
    >>> import numpy as np
    >>> np.random.seed(123)
    >>> signal = [np.random.rand() for _ in range(2560)]
    >>> sig_reference = [np.random.rand() for _ in range(2560)]
    >>> stObj = SignalTransform(signal, Fs = 64)
    >>> cco = stObj.get_cross_correlogram(sig_reference)
    >>> ps = stObj.get_power_spectrum()
    >>> sg = stObj.get_spectrogram()
    >>> bg = stObj.get_bissspectrogram()
        
    """
    __ps = None

    def __init__(self, signal: t.Optional[np.ndarray], 
                 Fs = 128.0, nw = 2.5, k = None):        
        self.signal = signal
        self.Fs = Fs
        self.nw = nw
        self.k = k

        # If k parameter is not instance, it is set to w * 2)
        if self.k == None:
            self.k = int(self.nw * 2)


    def get_cross_correlogram(self, signal_ref: t.Optional[np.ndarray]):
        """ It generates a cross-correlogram from a signal by using a reference
        
        Parameter
        ----------
        signal_ref : numpy.ndarray
            A signal used as reference for the cross-correlation application
            
        Return
        ------
            Cross-correlogram represented as numpy.ndarray

        """
        cc = None

        # The signal and reference must have the same length
        if len(self.signal) == len(signal_ref):
            # cross-correlation is applied for time-shift parameters between
            # -(len(self.signal) - 1) and len(self.signal)
            cc = [cross_correlation(self.signal, signal_ref, i) for i in 
                  range(-(len(self.signal) - 1), len(self.signal))]

        return np.asarray(cc)


    def __get_psd(self, sig, data_taper = None, eigen = None):
        """ It is a private method which generates a power spectrum. This 
        function is also used to generate a spectrogram by its repetitive
        execution ("__get_psd" function)
        
        Parameters
        ----------
        sig : numpy.ndarray (default = None)
            A time-domain signal.
            
        data_taper : numpy.ndarray
            Data tapers generated from k first Slepian sequences. This 
            parameter is a len(sig) X k numpy.ndarray.
            
        eigen : numpy.ndarray (default = None)
            Window concentrations (eigenvalues).
            
            
        Return
        ------
            Power spectrum represented as numpy.ndarray
        
        """
        ps = None
        
        if (data_taper is not None) and (eigen is not None):
            ps, w, _ = pmtm(sig, e = eigen, v = data_taper, show = False)
        else:
            ps, w, _ = pmtm(self.signal, NW = self.nw, k = self.k, show = False)
            
        # The resulted ps can have a length of 2*len(sig), in which half of its
        # components are redundant (the resulted ps is symmetric, according to
        # the Nyquist frequency).
        l = len(sig)
        ps = ps[:, 0 : l]
        w = w[0 : l, :]
        
        # Absolute square of components to generate a power spectrum
        # Previously, the ps was represented by complex numbers
        ps = abs(ps)**2
        
        ps = ps.transpose()
        
        # An one-dimensional power spectrum is generated by avaraging the ps
        # Previously, the ps is smoothed by using the weights w
        ps = np.mean(ps * w, axis = 1)
        
        return ps


    def get_power_spectrum(self, data_taper: t.Optional[np.ndarray] = None, 
                           eigen: t.Optional[np.ndarray] = None):
        """ It generates a power spectrum from a time-domain signal.
        Additional details is shown in the "__get_psd" function.
        
        Parameters
        ----------
        data_taper : numpy.ndarray (default = None)
            Data tapers generated from k first Slepian sequences. This 
            parameter is a len(sig) X k numpy.ndarray.
            
        eigen : numpy.ndarray (default = None)
            Window concentrations (eigenvalues).
        
        
        Observation
        -----------
            data_taper and eigen can be generate by using the "dpss" function 
            from the "spectrum" package. The previous generation of these 
            parameters is recommended if the multitaper is applied to 
            multiple signals because Slepian sequences have high computational
            cost for their generation. Also, it is important to emphasize that
            each data_taper must have same length in relation to the processed
            signal.
        
            
        Return
        ------
            Power spectrum represented as numpy.ndarray
        
        """
        self.__ps = self.__get_psd(self.signal, data_taper, eigen)

        return self.__ps
    
    
    def get_spectrogram(self, window_len: int = 128, 
                        data_taper: t.Optional[np.ndarray] = None, 
                        eigen: t.Optional[np.ndarray] = None):
        """ It generates a spectrogram from a time-domain signal.
        Additional details is shown in the "__get_psd" function. Also, in this
        function, data tapers are used as window function.
        
        Parameters
        ----------
        window_len : int (default = 128)
            Sliding window length.
        
        data_taper : numpy.ndarray (default = None)
            Data tapers generated from k first Slepian sequences. This 
            parameter is a len(sig) X k numpy.ndarray.
            
        eigen : numpy.ndarray (default = None)
            Window concentrations (eigenvalues).
        
            
        Return
        ------
            Spectrogram represented as numpy.ndarray
        
        """
        sg = []
        
        # data_taper and eigen parameter must be generated before the 
        # spectrogram generation aiming to save computational resources
        if (data_taper is None) or (eigen is None):
            data_taper, eigen = dpss(window_len, NW = self.nw, k = self.k)

        if len(self.signal) >= window_len:
            # For each i value, a power spectrum is generated to compose the
            # spectrogram
            for i in range(0, len(self.signal) - window_len + 1):
                sg.append(self.__get_psd(self.signal[i : i + window_len], 
                                         data_taper, eigen))

        sg = np.asarray(sg)

        return sg.T


    def get_bispectrogram(self, data_taper: t.Optional[np.ndarray] = None,
                          eigen: t.Optional[np.ndarray] = None):
        """ It generates a bispectrogram.
        
        Parameters
        ----------        
        data_taper : numpy.ndarray (default = None)
            Data tapers generated from k first Slepian sequences. This 
            parameter is a len(sig) X k numpy.ndarray.
            
        eigen : numpy.ndarray (default = None)
            Window concentrations (eigenvalues).
        
            
        Return
        ------
            Bispectrogram represented as numpy.ndarray
        
        """
        if self.__ps is None:
            self.__ps = self.get_power_spectrum(data_taper, eigen)

        bs = np.zeros((int(len(self.__ps) / 2) - 1, 
                       int(len(self.__ps) / 2) - 1))

        for i in range(0, len(bs)):
            for j in range(0, len(bs) - i):
                bs[i, j] = self.__ps[i] * self.__ps[j] * self.__ps[i + j]
                bs[j, i] = bs[i, j]
                bs[len(bs)- i - 1, len(bs[0]) - j - 1] = bs[i, j]
                bs[len(bs[0]) - j - 1, len(bs)- i - 1] = bs[i, j]

        return bs
