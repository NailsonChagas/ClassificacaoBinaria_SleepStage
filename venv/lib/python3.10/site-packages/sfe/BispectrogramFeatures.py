from math import *
#from sfe_aux_tools import *
from sfe.sfe_aux_tools import *
import numpy
from scipy.stats import kurtosis
from scipy.stats import skew

class BispectrogramFeatures:
    def __init__(self, bg, freq_sample, nfft, delta_power = [1, 4],
                 theta_power = [4, 8], alpha_power = [8, 12],
                 beta_power = [12, 30], gamma_power = [30, 60]):
        self.bg = bg
        self.Fs = freq_sample
        self.nfft = nfft
        self.__fg = getfgrid(freq_sample, nfft)
        self.delta_p = delta_power
        self.theta_p = theta_power
        self.alpha_p = alpha_power
        self.beta_p = beta_power
        self.gamma_p = gamma_power


    def extract_features(self, delta_f = True, theta_f = True,
                         alpha_f = True, beta_f = True, gamma_f = True,
                         entire_f = True, label = ''):
        features = {}

        if (delta_f):
            delta_fg = spectrum_filter(self.__fg, self.Fs, self.delta_p)
            delta_bg = bispectrum_filter(self.bg, self.Fs, self.delta_p, self.delta_p)
            features.update(self.__compute_measures(delta_bg, delta_fg, range_f_label = 'delta' + label))

        if (theta_f):
            theta_fg = spectrum_filter(self.__fg, self.Fs, self.theta_p)
            theta_bg = bispectrum_filter(self.bg, self.Fs, self.theta_p, self.theta_p)
            features.update(self.__compute_measures(theta_bg, theta_fg, range_f_label = 'theta' + label))

        if (alpha_f):
            alpha_fg = spectrum_filter(self.__fg, self.Fs, self.alpha_p)
            alpha_bg = bispectrum_filter(self.bg, self.Fs, self.alpha_p, self.alpha_p)
            features.update(self.__compute_measures(alpha_bg, alpha_fg, range_f_label = 'alpha' + label))

        if (beta_f):
            beta_fg = spectrum_filter(self.__fg, self.Fs, self.beta_p)
            beta_bg = bispectrum_filter(self.bg, self.Fs, self.beta_p, self.beta_p)
            features.update(self.__compute_measures(beta_bg, beta_fg, range_f_label = 'beta' + label))

        if (gamma_f):
            gamma_fg = spectrum_filter(self.__fg, self.Fs, self.gamma_p)
            gamma_bg = bispectrum_filter(self.bg, self.Fs, self.gamma_p, self.gamma_p)
            features.update(self.__compute_measures(gamma_bg, gamma_fg, range_f_label = 'gamma' + label))

        if (entire_f):
            features.update(self.__compute_measures(self.bg, self.__fg, range_f_label = 'entire' + label))

        return features


    #def __generate_interrange_dependency_bg(self, bg, freq_range1, freq_range2){
    #    if (freq_range1 == freq_range2):
    #        return bispectrum_filter(self.bg, self.Fs, freq_range1, freq_range1)
    #
    #    return bispectrum_filter(self.bg, self.Fs, freq_range1, freq_range2)
    #}


    def __generate_feature_dictionary(self, range_f_label):
        dic_features = {'1st_order_diag_amplitude_' + range_f_label: None,
                        '2nd_order_diag_amplitude_' + range_f_label: None,
                        'normalized_entropy_' + range_f_label: None,
                        'normalized_quadractic_entropy_' + range_f_label: None,
                        'mean_magnitude_' + range_f_label: None,
                        'weighted_center_X_' + range_f_label: None,
                        'weighted_center_Y_' + range_f_label: None,
                        'sum_absolute_log_' + range_f_label: None}

        return dic_features


    def __compute_measures(self, bg, fg, range_f_label = ''):
        dic_features = self.__generate_feature_dictionary(range_f_label)

        print(range_f_label)

        dic_features['1st_order_diag_amplitude_' + range_f_label] = self.__1st_order_diagonal_amplitude(bg, fg)
        dic_features['2nd_order_diag_amplitude_' + range_f_label] = self.__2nd_order_diagonal_amplitude(bg, fg)
        dic_features['normalized_entropy_' + range_f_label] = self.__normalized_entropy(bg)
        dic_features['normalized_quadractic_entropy_' + range_f_label] = self.__normalized_quadractic_entropy(bg)
        dic_features['mean_magnitude_' + range_f_label] = self.__mean_magnitude(bg)
        dic_features['weighted_center_X_' + range_f_label] = self.__weighted_center_X(bg)
        dic_features['weighted_center_Y_' + range_f_label] = self.__weighted_center_Y(bg)
        dic_features['sum_absolute_log_' + range_f_label] = self.__sum_absolute_log(bg)

        return dic_features


    def __1st_order_diagonal_amplitude(self, bg, fg):
        fst_moment = 0

        for i in range(0, floor(len(bg) / 2)):
            fst_moment += fg[i] * log10(sqrt(bg[i, i]))

        return fst_moment


    def __2nd_order_diagonal_amplitude(self, bg, fg):
        amp = 0

        for i in range(0, floor(len(bg) / 2)):
            amp += (fg[i] ** 2) * log10(sqrt(bg[i, i]))

        return amp


    def __normalized_entropy(self, bg):
        sumPm = 0
        pm = []
        k = 0

        for i in range(0, floor(len(bg) / 2)):
            for j in range(i + k, len(bg[0]) - k):
                pm.append(sqrt(bg[i, j]))
                sumPm += pm[len(pm) - 1]

            k += 1

            #j = len(bg) - i - 1
            #
            #while ((j >= i) and (bg[i, j] > 0)):
            #    pm.append(sqrt(bg[i, i]))
            #    sumPm += pm[len(pm) - 1]
            #    j -= 1

        pm = numpy.asarray(pm) / sumPm

        return - sum(pm * numpy.log10(pm))


    def __normalized_quadractic_entropy(self, bg):
        sumQm = 0
        qm = []
        k = 0

        for i in range(0, floor(len(bg) / 2)):
            for j in range(i + k, len(bg[0]) - k):
                qm.append(bg[i, j])
                sumQm += qm[len(qm) - 1]

            k += 1

            #j = len(bg) - i - 1
            #
            #while ((j >= i) and (bg[i, j] > 0)):
            #    qm.append(bg[i, i])
            #    sumQm += qm[len(qm) - 1]
            #    j -= 1

        qm = numpy.asarray(qm) / sumQm

        return - sum(qm * numpy.log10(qm))


    def __mean_magnitude(self, bg):
        r = 0
        sumMM = 0
        k = 0

        for i in range(0, floor(len(bg) / 2)):
            for j in range(i + k, len(bg[0]) - k):
                sumMM += sqrt(bg[i, j])
                r += 1

            k += 1

            #j = 0
            #
            #while ((j <= i) and (bg[i, j])):
            #    sumMM += sqrt(bg[i, j])
            #
            #    r += 1
            #    j += 1

        return sumMM / r


    def __weighted_center_X(self, bg):
        pS = 0
        sumW = 0
        k = 0

        for i in range(0, floor(len(bg) / 2)):
            for j in range(i + k, len(bg[0]) - k):
                sumW += sqrt(bg[i, j])
                pS += i * sqrt(bg[i, j])

            k += 1

            #j = 0
            #
            #while ((j <= i) and (bg[i, j])):
            #    sumW += sqrt(bg[i, j])
            #    pS += j * sqrt(bg[i, j])
            #    j += 1

        return pS / sumW


    def __weighted_center_Y(self, bg):
        pS = 0
        sumW = 0
        k = 0

        for i in range(0, floor(len(bg) / 2)):
            for j in range(i + k, len(bg[0]) - k):
                sumW += sqrt(bg[i, j])
                pS += j * sqrt(bg[i, j])

            k += 1

            #j = 0
            #
            #while ((j <= i) and (bg[i, j])):
            #    sumW += sqrt(bg[i, j])
            #    pS += i * sqrt(bg[i, j])
            #    j += 1

        return pS / sumW


    # "Bispectrum-based feature extraction technique for devising a practical brainâ€“computer interface"
    def __sum_absolute_log(self, bg):
        sa = 0
        k = 0

        for i in range(0, floor(len(bg) / 2)):
            for j in range(i + k, len(bg[0]) - k):
                sa += np.log10(bg[i, j])

            k += 1

            #j = 0
            #
            #while ((j <= i) and (bg[i, j])):
            #    sa += np.log10(bg[i, j])
            #    j += 1

        return sa
