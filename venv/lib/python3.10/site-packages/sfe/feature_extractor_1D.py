''' Module implemented for feature extraction from one-dimensional sequences.
    Sequence examples: univariate time series, cross-correlogram, or 
    power spectrum

    @author: Jefferson Tales Oliva
    @email: jeffersonoliva@utfpr.edu.br


    References
    ----------
    Boonyakitanont, P.; Lek-uthai, A.; Chomtho, K.; Songsiri, J. A review of 
    feature extraction and performance evaluation in epileptic seizure 
    detection using EEG. Biomedical Signal Processing and Control, v. 57, 
    p. 101702, 2020.
    
    Chandaka, S.; Chatterjee, A.; Munshi, S. Cross-correlation aided support 
    vector machine classifier for classification of EEG signals. 
    Expert Systems with Applications, v. 36, n. 2, p. 1329-1336, 2009.
    
    Costa, M., Goldberger, A. L., Peng, C. K. Multiscale entropy analysis of 
    biolgical signals. Physical Review E, v. 71, n. 2, p. 021906, 2005
    
    Easton Jr, R. L. Fourier methods in imaging. John Wiley & Sons, 2017.
    
    Fredman, D.; Pisani, R.; Ourvers, R. Statistics. Norton, 1988.
    
    Johnston, J. D. Transform coding of audio signals using perceptual noise 
    criteria. IEEE Journal on selected areas in communications, IEEE, v. 6, 
    n. 2, p. 314–323, 1988. 
    
    Oliva, J. T. Automatic generation of medical reports for epilepsy diagnosis
    through electroencephalogram processing using machine learning (in 
    Portuguese). PhD Thesis -- University of São Paulo (USP), São Carlos, 
    Brazil, 2018.

    Oliva, J. T., Rosa, J. L. G. Classification for EEG report generation and 
    epilepsy detection. Neurocomputing, v. 335, p. 81--95, 2019.
    
    Proakis, J. G.; Manolakis, D. K. Digital signal processing: principles, 
    algorithms, and application. Saddle River, EUA: Prentice Hall, 2006.
    
    Ramaligam, A.; Krishnan, S. Gaussian mixture modeling using short time 
    Fourier transform features for audio fingerprinting. In: IEEE, 14. 
    Proceedings of the International Conference on Multimedia and Expo. 
    Amsterdam, Netherlands, 2005. 
    
    Shannon, C. E. A mathematical theory of communication. The Bell System 
    Technical Journal, IEEE, v. 27, n. 3, p. 379–423, 1948.
    
    Sweitzer, K.; Bishop, N.; Genberg, V. Efficient computation of spectral 
    moments for determination of random response statistics. 2004.
    
    Zhou, S.; Gan, J. Q.; Sepulveda, F. Classifying mental tasks based on 
    features of higherorder statistics from EEG signals in brain–computer 
    interface. Information Sciences, Elsevier, v. 178, n. 6, p. 1629–1640, 
    2008.
    
    
    Links
    -----
    http://pyeeg.sourceforge.net/#pyeeg
    https://www.johndcook.com/blog/2018/11/21/renyi-entropy/
    https://www.researchgate.net/post/Selection_criteria_for_Approximate_Entropy_parameters_ApEndata_m_r
    http://pyeeg.sourceforge.net/#pyeeg.ap_entropy
    https://en.wikipedia.org/wiki/Approximate_entropy
    https://en.wikipedia.org/wiki/Sample_entropy
    
'''
from sfe.sfe_aux_tools import getfgrid
import numpy as np
import typing as t
from collections import Counter
from scipy.stats import kurtosis, skew


class ODFeatureExtractor:
    """One-dimensional array feature extractor: This class provides methods for
    feature extraction from time- or frequency-domain representations of
    signals.
    
    Attributes
    ----------
    seq : numpy.ndarray
        Sequence which represents a cross-correlogram (time domain) or power
        spectrum (frequency domain)
    
    freq_grid : numpy.ndarray (default = None)
        Frequency grid that represent the frequency values of the "seq" 
        elements. For example, the i-th "seq" element is sampled at 
        freq_grid[i] Hz. In this sense, if "freq_grid" has default 
        value (None) or is not created, extracted features are from time domain,
        i.e. some measures can not be extracted, such as peak frequency, 
        1st-order moment, 2nd-order moment, spectral centroid, and spectral 
        entropy. If "freq_grid" is different from None or created during the
        "ODFeatureExtractor" instancing, all measures can be computed.
    
    label : string (default = '')
        String concatenated to each feature name. In an electroencephalogram,
        for example, power spectrum features are commonly extracted by 
        frequency range, such as delta [1-4 Hz], theta [4-8 Hz], 
        alpha [8--12 Hz], etc. Thus, the "delta" label could be concatenated to
        each feature name during its extraction into delta range from a power
        spectrum.
        
        __extracted_features : dict (default = {})
            A dictionary which represents a set of extracted features.
        
    __mean: int or float (default = None)
        Sequence average.
            
    __std: int or float (default = None)
        Sequence standard deviation.
            
    __min: int or float (default = None)
        Sequence minimum value.
            
    __peak: int or float (default = None)
        Sequence maximum value.
            
    __peak_frequency: int or float (default = None)
        Frequency of peak sequence.
            
    __Q1: int or float (default = None)
        First quartile.
            
    __Q2: int or float (default = None)
        Second quartile.
            
    __Q3: int or float (default = None)
        Third quartile. 
            
    __Q_range: int or float (default = None)
        Difference between "__Q3" and "__Q1".
            
    __amplitude: int or float (default = None)
        Difference "__peak" and "__min".
            
    __spec_centroid: int or float (default = None)
        Spectral centroid.
            
    __kurtosis: int or float (default = None)
        Sequence kurtosis.
            
    __skewness: int or float (default = None)
        Sequence skewness.
            
    __coef_var: int or float (default = None)
        Coefficient of variation
            
    __flatness: int or float (default = None)
        Sequence flatness.
            
    __1st_moment: int or float (default = None)
        First order moment.
            
    __2nd_moment: int or float (default = None)
        Second order moment. 
            
    __rms: int or float (default = None)
        Sequence root main square.
            
    __crest_factor: int or float (default = None)
        Sequence crest factor.
            
    __line_length: int or float (default = None)
        Sequence line length.
            
    __nonlinear_energy: int or float (default = None)
        Sequence nonlinear energy.
            
    __Hurst_exponent: int or float (default = None)
        Hurst exponent. 
            
    __Hjorth_activity: int or float (default = None)
        A Hjorth parameter.
            
    __Hjorth_mobility: int or float (default = None)
        A Hjorth parameter. 
            
    __Hjorth_complexity: int or float (default = None)
        A Hjorth parameter. 
            
    __spectral_entropy: int or float (default = None)
        Spectral entropy.
            
    __Renyi_entropy: int or float (default = None)
        Renyi entropy.
            
    __Shannon_entropy: int or float (default = None)
        Shannon entropy.
            
    __approx_entropy: int or float (default = None)
        Approximate entropy.
            
    __sample_entropy: int or float (default = None)
        Sample entropy.
        
    """
    __extracted_features = {}
    
    __mean = None
    __std = None
    __min = None
    __peak = None
    __peak_frequency = None
    __Q1 = None
    __Q2 = None
    __Q3 = None
    __Q_range = None
    __amplitude = None
    __spec_centroid = None
    __kurtosis = None
    __skewness = None
    __coef_var = None
    __flatness = None
    __1st_moment = None
    __2nd_moment = None
    __rms = None
    __crest_factor = None
    __line_length = None
    __nonlinear_energy = None
    __Hurst_exponent = None
    __Hjorth_activity = None
    __Hjorth_mobility = None
    __Hjorth_complexity = None
    __spectral_entropy = None
    __Renyi_entropy = None
    __Shannon_entropy = None
    __approx_entropy = None
    __sample_entropy = None


    def __init__(self, seq: t.Optional[np.ndarray], Fs = None,
                 freq_grid: t.Optional[np.ndarray] = None, label = ''):
        """
        Non-instantiable parameter:
        ---------------------------
        Fs : int or float (default = None)
            Frequency sampling rate. If this parameter is not None, a frequency
            grid ("freq_grid") is created for extraction of some features based
            on power spectrum.
            
        """
        self.label = label

        self.seq = seq

        # If Fs or freq_grid is different from None, seq is a power 
        # spectrum (frequency domain). Otherwise, seq is a time series (time 
        # domain)
        if Fs is not None:
            self.freq_grid = getfgrid(Fs, len(seq))
        else:
            self.freq_grid = freq_grid


    def get_mean(self):
        """ It computes the average from an one-dimensional sequence (cross-
        correlogram or power spectrum).
        
        Return
        ------
            Sequence average as float
        
        """
        if self.__mean is None:
            self.__mean = self.seq.mean()
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'mean_' + self.label: 
                self.__mean})

        return self.__mean


    def get_std(self):
        """ It computes the standard deviation from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
            Standard deviation from a sequence as float
        
        """
        if self.__std is None:
            self.__std = self.seq.std()
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'std_' + self.label: self.__std})

        return self.__std


    def get_min(self):
        """ It computes the minimum from an one-dimensional sequence (cross-
        correlogram or power spectrum).
        
        Return
        ------
            Minimum value from a sequence as float
        
        """
        if self.__min is None:
            self.__min = self.seq.min()
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'min_' + self.label: self.__min})

        return self.__min


    def get_peak(self):
        """ It computes the maximum from an one-dimensional sequence (cross-
        correlogram or power spectrum).
        
        Return
        ------
            Maximum value from a sequence as float
        
        """
        if self.__peak is None:
            self.__peak = self.seq.max()
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'peak_' + self.label: 
                self.__peak})

        return self.__peak


    def get_peak_frequency(self):
        """ It computes the peak from a power spectrum if "the freq_grid" is
        different from None.
        
        Return
        ------
            Peak frequency value from a sequence as float
        
        """
        if (self.__peak_frequency is None) and (self.freq_grid is not None):
            ma = self.__peak # maximum
            
            if ma is None:
                ma = self.seq.max()
            
            self.__peak_frequency = self.freq_grid[self.seq.tolist().index(ma)]
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'peak_frequency_' + self.label:
                self.__peak_frequency})

        return self.__peak_frequency


    def get_Q1(self):
        """ It computes the first quartile from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
            First quartile value from a sequence as float
        
        """
        if self.__Q1 is None:
            self.__Q1 = np.percentile(self.seq, 25)
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'Q1_' + self.label: self.__Q1})

        return self.__Q1


    def get_Q2(self):
        """ It computes the second quartile from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
            Second quartile value from a sequence as float
        
        """
        if self.__Q2 is None:
            self.__Q2 = np.percentile(self.seq, 50)
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'Q2_' + self.label: self.__Q2})

        return self.__Q2


    def get_Q3(self):
        """ It computes the third quartile from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
            Thrird quartile value from a sequence as float
        
        """
        if self.__Q3 is None:
            self.__Q3 = np.percentile(self.seq, 75)
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'Q3_' + self.label: self.__Q3})

        return self.__Q3


    def get_Q_range(self):
        """ It computes the interquartile range from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
            Interquartile range value from a sequence as float
        
        """
        if self.__Q_range is None:
            q1 = self.__Q1 # first quartile
            q3 = self.__Q3 # third quartile
            
            if q1 is None:
                q1 = np.percentile(self.seq, 25)
                
            if q3 is None:
                q3 = np.percentile(self.seq, 75)
            
            self.__Q_range = q3 - q1
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'Q_range_' + self.label:
                self.__Q_range})

        return self.__Q_range


    def get_amplitude(self):
        """ It computes the difference between the maximum (peak)  and minimum
        values from an one-dimensional sequence (cross-correlogram or power 
        spectrum).
        
        Return
        ------
            Amplitude value from a sequence as float
        
        """
        if self.__amplitude is None:
            mi = self.__min # minimum
            ma = self.__peak # maximum
            
            if mi is None:
                mi = self.seq.min()
            
            if ma is None:
                ma = self.seq.max()
            
            self.__amplitude = ma - mi
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'amplitude_' + self.label:
                self.__amplitude})

        return self.__amplitude


    def get_spec_centroid(self):
        """ It computes the spectral centroid from a power spectrum if the 
        "freq_grid" attribute is different from None.
        
        Return
        ------
            Spectral value from a sequence as float
        
        """
        if (self.__spec_centroid is None) and (self.freq_grid is not None):
            self.__spec_centroid = np.sum(self.seq * self.freq_grid) / np.sum(self.seq)
                                          
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'spec_centroid_' + self.label: 
                self.__spec_centroid})

        return self.__spec_centroid


    def get_kurtosis(self):
        """ It computes the kurtosis from an one-dimensional sequence (cross-
        correlogram or power spectrum).
        
        Return
        ------
            Kurtosis value from a sequence as float
        
        """
        if self.__kurtosis is None:
            self.__kurtosis = kurtosis(self.seq)
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'kurtosis_' + self.label:
                self.__kurtosis})

        return self.__kurtosis


    def get_skewness(self):
        """ It computes the skewness from an one-dimensional sequence (cross-
        correlogram or power spectrum).
        
        Return
        ------
            Skewness value from a sequence as float
        
        """
        if self.__skewness is None:
            self.__skewness = skew(self.seq)
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'skewness_' + self.label:
                self.__skewness})

        return self.__skewness


    def get_coef_var(self):
        """ It computes the coefficient of variation from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
            Coefficient value from a sequence as float
        
        """
        if self.__coef_var is None:
            me = self.__mean # mean
            sd = self.__std # standard deviation
            
            if me is None:
                me = self.seq.mean()
                
            if sd is None:
                sd = self.seq.std()
            
            self.__coef_var = me / sd
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'coef_var_' + self.label:
                self.__coef_var})

        return self.__coef_var


    def get_flatness(self):
        """ It computes the flatness from an one-dimensional sequence (cross-
        correlogram or power spectrum).
        
        Return
        ------
            Flatness value from a sequence as float
        
        """
        if self.__flatness is None:
            me = self.__mean
            
            if me is None:
                me = self.seq.mean()

            # See equation in https://en.wikipedia.org/wiki/Spectral_flatness
            self.__flatness = np.exp(np.average(np.log10(self.seq[self.seq > 
                                                                  0]))) / me
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'flatness_' + self.label:
                self.__flatness})

        return self.__flatness


    def get_1st_moment(self):
        """ It computes the first-order moment from a power spectrum if the 
        "freq_grid" attribute is different from None.
        
        Return
        ------
            First-order moment value from a sequence as float
        
        """
        if (self.__1st_moment is None) and (self.freq_grid is not None):
            self.__1st_moment = np.sum(self.seq * self.freq_grid)
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'1st_moment_' + self.label:
                self.__1st_moment})

        return self.__1st_moment


    def get_2nd_moment(self):
        """ It computes the second-order moment from a power spectrum if the
        "freq_frid" attribute is different from None.
        
        Return
        ------
            Second-order moment value from a sequence as float
        
        """
        if (self.__2nd_moment is None) and (self.freq_grid is not None):
            self.__2nd_moment = np.sum((self.seq ** 2) * self.freq_grid)
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'2nd_moment_' + self.label:
                self.__2nd_moment})

        return self.__2nd_moment


    def get_rms(self):
        """ It computes the root mean square from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
            Root mean square value from a sequence as float
        
        """
        if self.__rms is None:
            self.__rms = self.__root_mean_square()
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'rms_' + self.label: self.__rms})

        return self.__rms
    
    
    def __root_mean_square(self):
        """ Computes the root mean square.
        
        See the "get_rms" method for more details.
        """
        return np.sqrt(sum(self.seq ** 2)) / len(self.seq)


    def get_crest_factor(self):
        """ It computes the crest factor from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
            Crest factor value from a sequence as float
        
        """
        if self.__crest_factor is None:
            p = self.__peak # maximum
            r = self.__rms # root mean square
            
            if p is None:
                p = self.seq.max()
                
            if r is None:
                r = self.__root_mean_square()
            
            self.__crest_factor = p / r
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'crest_factor_' + self.label:
                self.__crest_factor})

        return self.__crest_factor


    def get_line_length(self):
        """ It computes the line length from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
            Line Length value from a sequence as float
        
        """
        if self.__line_length is None:
            self.__line_length = np.sum(
                    [abs(self.seq[i] - self.seq[i - 1]) for i in range(1, len(
                            self.seq))])
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'line_length_' + self.label: 
                self.__line_length})

        return self.__line_length


    def get_nonlinear_energy(self):
        """ It computes the nonlinear energy from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
            Nonlinear energy value from a sequence as float
        
        """
        if self.__nonlinear_energy is None:
            self.__nonlinear_energy = np.sum([
                    abs(self.seq[i]**2 - self.seq[i + 1] * self.seq[i - 1]) 
                    for i in range(1, len(self.seq) - 1)])
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'nonlinear_energy_' + self.label:
                self.__nonlinear_energy})

        return self.__nonlinear_energy


    def get_Hurst_exponent(self):
        """ It computes the Hurst exponent from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
            Hurst exponent from a sequence as float
        
        """
        if self.__Hurst_exponent is None:
            self.__Hurst_exponent = self.__mean
            
            if self.__Hurst_exponent is None:
                self.__Hurst_exponent = self.seq.mean()
            
            y = self.seq - self.__Hurst_exponent
            z = [np.sum(y[0 : i + 1]) for i in range(0, len(y))]

            self.__Hurst_exponent = np.log10((np.max(z) - np.min(z)) / 
                                               np.std(z))
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'Hurst_exponent_' + self.label:
                self.__Hurst_exponent})

        return self.__Hurst_exponent


    def get_Hjorth_parameters(self):
        """ It computes the Hjorth parameters from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
           The  Hjorth parameters from a sequence as float
        
        """
        if self.__Hjorth_activity is None:
            self.__Hjorth_activity = np.var(self.seq)

        if self.__Hjorth_mobility is None:
            self.__Hjorth_mobility = np.sqrt(np.var(np.diff(self.seq)) / 
                                               self.__Hjorth_activity)

        if self.__Hjorth_complexity is None:
            self.__Hjorth_complexity = np.sqrt(
                    np.var(np.diff(self.seq, 2)) / self.__Hjorth_activity
                    ) / self.__Hjorth_mobility
            
                    
            # The Hjorth parameters are added into the "extracted_features" 
            # dictionary
            self.__extracted_features.update({'Hjorth_activity_' + self.label:
                self.__Hjorth_activity})
            
            self.__extracted_features.update({'Hjorth_mobility_' + self.label:
                self.__Hjorth_mobility})
            
            self.__extracted_features.update({'Hjorth_complexity_' + 
                                              self.label: self
                                              .__Hjorth_complexity})

        return self.__Hjorth_activity, self.__Hjorth_mobility, self.__Hjorth_complexity


    def get_Shannon_entropy(self):
        """ It computes the Shannon entropy from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
           Shannon entropy value from a sequence as float
        
        """
        if self.__Shannon_entropy is None:
            l = len(self.seq)

            self.__Shannon_entropy = np.sum([-(n / l) * np.log2(n / l) for x, n
                                             in Counter(self.seq).items()])
           
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'Shannon_entropy_' +  self.label:
                self.__Shannon_entropy})

        return self.__Shannon_entropy


    def get_Renyi_entropy(self, alpha = 0.05):
        """ It computes the Renyi entropy from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Parameter
        ---------
        alpha: int or float (default = 0.05)
            Order of the Renyi entropy. This parameter must be positive and 
            different from 1. Special cases for Renyi entropy:
                - alpha = 0: max-entropy.
                - alpha = 1 (not allowed in this function): Shannon entropy.
                - alpha = 2: collision entropy.
                - alpha = Inf: max-entropy.
        
        
        Return
        ------
           Renyi entropy value from a sequence as float
        
        """
        if (self.__Renyi_entropy is None) and (alpha >= 0) and (alpha != 1):
            self.__Renyi_entropy = (1 / (1 - alpha)) * np.log10(np.sum(
                    [(n / len(self.seq))** alpha for x, n in Counter(
                            self.seq).items()]))
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'Renyi_entropy_' + self.label: 
                self.__Renyi_entropy})

        return self.__Renyi_entropy


    def get_spectral_entropy(self):
        """ It computes the spectral entropy from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        Return
        ------
           Spectral entropy value from a sequence as float
        
        """
        if (self.__spectral_entropy is None) and (self.freq_grid is not None):
            self.__spectral_entropy = - np.sum(self.seq * np.log10(self.seq))
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'spectral_entropy_' + self.label:
                self.__spectral_entropy})

        return self.__spectral_entropy


    def get_approx_entropy(self, m: t.Optional[int] = 2, r = 2):
        """ It computes the approximate entropy from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        This method is an adaptation of the code presented in:
            https://en.wikipedia.org/wiki/Approximate_entropy
        
        Parameter
        ---------
        m: int (default = 2)
            Pattern length.
        
        r: int or float (default = 2)
            Filtering level.
        
        Return
        ------
           Approximate entropy value from a sequence as float
        
        """
        if self.__approx_entropy is None:
            self.__approx_entropy = abs(self.__phi(m + 1, r) - 
                                          self.__phi(m, r))
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'approx_entropy_' + self.label: 
                self.__approx_entropy})

        return self.__approx_entropy


    # this function aims to measure \phi^m(r)
    def __phi(self, m, r):
        """ It computes the magnitude of the $m$ subsequences generated from
        a sequence ("").
        
        Parameter
        ---------
        m: int (default = 2)
            Pattern length.
        
        r: int or float (default = 2)
            Filtering level.
        
        Return
        ------
           Magnitude value from a sequence as float
        
        """
        l = len(self.seq)

        # It generates N - m + 1 sequences with size m: (l - m + 1) X (M) 
        # matrix
        mat = np.asarray([[self.seq[j] for j in range(i, i + m)] for i in 
                           range(l - m + 1)])

        # C in latex representation: C_{i}^{m}(r)
        C = np.asarray([np.sum(np.abs(x - mat).max(axis=1) <= r) / (l - m + 
                        1.0) for x in mat])

        return (l - m + 1.0) ** (-1) * np.sum(np.log(C))


    def get_sample_entropy(self, m = 2, r = 2):
        """ It computes the sample entropy from an one-dimensional 
        sequence (cross-correlogram or power spectrum).
        
        This method is an adaptation of the code presented in:
            https://en.wikipedia.org/wiki/Sample_entropy
            
        
        Parameter
        ---------
        m: int (default = 2)
            Pattern length.
        
        r: int or float (default = 2)
            Filtering level.
        
        Return
        ------
           Sample entropy value from a sequence as float
        
        """
        if self.__sample_entropy is None:
            l = len(self.seq)
            B = 0.0
            A = 0.0

            xmi = np.array([self.seq[i : i + m] for i in range(l - m)])
            
            xmj = np.array([self.seq[i : i + m] for i in range(l - m + 1)])

            B = np.sum([np.sum(np.abs(xmii - xmj).max(axis=1) <= r) - 1 for 
                        xmii in xmi])

            m += 1
            
            xm = np.array([self.seq[i : i + m] for i in range(l - m + 1)])

            A = np.sum([np.sum(np.abs(xmi - xm).max(axis=1) <= r) - 1 for 
                        xmi in xm])
            

            self.__sample_entropy = -np.log(A / B)
            
            # The feature is added into the "extracted_features" dictionary
            self.__extracted_features.update({'sample_entropy_' + self.label: 
                self.__sample_entropy})

        return self.__sample_entropy


    def extract_all_features(self, alpha = 0.05, m = 2, r = 2):
        """ It extract all cross-correlogram or power spectrum features 
        implemented in this file.
        
        Parameter
        ---------
        alpha: see "get_Renyi_entropy".
        
        m and r: see "get_approx_entropy" or "get_sample_entropy".
        
        """
        self.get_mean()
        self.get_std()
        self.get_peak()
        self.get_min()
        self.get_peak_frequency()
        self.get_Q1()
        self.get_Q2()
        self.get_Q3()
        self.get_Q_range()
        self.get_amplitude()
        self.get_spec_centroid()
        self.get_kurtosis()
        self.get_skewness()
        self.get_coef_var()
        self.get_flatness()
        self.get_1st_moment()
        self.get_2nd_moment()
        self.get_rms()
        self.get_crest_factor()
        self.get_line_length()
        self.get_nonlinear_energy()
        self.get_Hurst_exponent()
        self.get_Hjorth_parameters()
        self.get_Shannon_entropy()
        self.get_Renyi_entropy(alpha)
        self.get_approx_entropy(m, r)
        self.get_sample_entropy(m, r)


    def get_extracted_features(self):
        """ It returns all extracted features.
        
        Return
        ---------
        The extracted features as dict
        
        """
        return self.__extracted_features